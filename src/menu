
人生和技术
        https://www.processon.com/diagraming/5c1b64a8e4b095ccfee8d4ae
        维度
        问题的非等价转移 解决方案的取舍

        产品开发经验总结-让你少奋斗一年的经验之谈
            https://www.cnblogs.com/lixinghua/p/9745870.html
        pjs仿真设计

***** 无论是哪个设计，架构、数据库、类..都是在对  ‘ 业务特别了解，对未来发展方向预测；并合理抽象   ’+ 混合编程、全栈编程*****
***** 最后发现，官方文档才是正规的。也是最可以扩展点。可以完全信赖’*****
 不断迭代才是真理，不要想着一次设计就是最终，那是不可能，高手也是迭代思考出来的，不要害怕丑陋，解决就好
----------工业化-----如何去学习新技术和阅读源码？  1.官方文档 quickstart   2.熟练使用，解决问题  3.指导性文件总体思路，带着问题、答案去阅读部分源码，不要试图一次搞清楚所有的架构和实现，容易迷失！


------NEED ---- 按照阿里归范编写代码，每次提交进行对应代码扫描 ------


  需求 - 仿真表设计2 从业务需求出发，设计表，保证字段  ---> 反模式+mysql..表架构  ---> 下面的具体实现 ---> 分库分表分布式环境下
   ===> 其实无论是架构还是类，都是从业务-架构-实现往下走，粒度越来越细

        _____而那些看到别人代码有点瑕疵就一顿乱骂，或者花尽心思去构
             思一个完美设计的人，往往都是因为没有树立正确的代码质量观，没有持续重构意识。_____
        人生也是如此，没有说没有问题的。人生就是面对、解决。学习接受能力


   -1:编码命名归范  naming.class

   0.架构设计  https://blog.csdn.net/hguisu/article/details/78258430
       ===> 3.0详设版本1.0 -> 2.0 业务需求文档从业务角度出发 --> 详设从系统，开发角度 泳道图 交互。这种转化也是 ‘代码开发’的依据而不是业务流程图
       ===> 仿真文档自己版  -> 李老师版本  场景全面 - 可行性 - 从简单实例完成到迭代
       ===> processon 仿真演进过程


   1.表设计
           1>设计表结构：RuleDo.java + statusDo.class（状态机表 - 未考虑字段、继承、业务等 -- 需要重新结合看的书写）
                如何编写高效sql: 函数..(好的表设计肯定是设计时就考虑了查询，所以可能有冗余)
                利用数据库主键冲突做唯一控制 分布式下
               C:\Users\73699\Desktop\think\极客时间\06-MySQL实战45讲
               C:\Users\73699\Desktop\think\表设计思考\反模式
               C:\Users\73699\Desktop\think\表设计思考\深入浅出MySQL数据库开发优化与管理维护

            2>.sql(转化思路重写sql?)
               RuleDoMapper.interface
               C:\Users\73699\Desktop\think\极客时间\44-SQL必知必会


      如何编写工具类：JaxbUtil.class
   2. 学习新模块的方式学习实践
      MybatisMain
      AnnotationValidateFrameWork-UserAspect(切面)-ControllerAdvice
      QurarzMain(timing.quartz目录都是)
      AmqMsgContainerFactory(activemq) - RPCManager - DefaultProducer(rocketmq)
      RedisUse -RedisCacheConfiguer CacheManager
      LogMain
   --结合下面的章节3.类
      Java8Main
      ReflectMain
      UtilMain - hutool
      ThreadMain - MainClass - Hmain
      PatternMain - 设计模式复合使用(本文档中)

      DubboMain
      WebContainerMain - springmvc - session / servlet
      ZookeeperMain
      ShardingJdbcMain
      ElesticSearchMain
      DroolsMain

      ProductMain


                 Callback + ICache ++ MVC.java +
                                 + PorformMain)
            - 从jdk的使用什么 -- 到这里的不同的模块注意什么、如何融合  --- 这些也是基础学习以后可以在自己扩展或使用别人的博客
         1.登录官网  quickstart   https://rocketmq.apache.org/docs/quick-start/   + 左侧对应的其他example和tips + best practice就是核心设计-源码注意点

         2.既然写模块，肯定要结合起来写 实现企业级 - 不要嘲笑工具的使用，因为直接接触的就是你对使用越合理越熟练才会越好。原理是用来提升的
             那么如何和springboot 整合呢  查看springboot文档   -- 繁多并且都是一些简单的(高层次)，肯定根据经验删选重要的，--->跑起来
                    springboot:https://spring.io/projects/spring-framework  - 最权威的，官方的，所有博客师出同门
                    spring:https://docs.spring.io/spring/docs/5.2.3.RELEASE/spring-framework-reference/index.html ***spring中核心的类，扩展，使用说明***
                           *****  https://spring.io/guides *****使用示例
             springboot:
                         1.@configure和@bean 将引入的模块注入到spring管理，其中的属性来自前面该模块需要注意的东西+配置文件配置+方法中判断 = spring中xml配置 - 跑起来
                         2.https://docs.spring.io/spring-boot/docs/2.3.0.BUILD-SNAPSHOT/reference/html/spring-boot-features.html#boot-features  整合 配置信息一部分用于
                           springbootstarter内部判断 ，一部分需要在bean定义时判断 ${"xx"}

             以redis整合为例，查看如何spring和jedis结合
                 一直到 JedisConnectionFactory  终于找到了关于jedis的引用
                 - PersistenceExceptionTranslator（统一异常处理） -RedisConnectionFactory - JedisConnectionFactory
                 											   	- redisTempate 	- xxmanager(RedisCacheWriter - RedisCacheConfiguration)abstract..cacheMaxx
                 																																																封装子系统中的多个api,无需客户端组合 build /create / get..
                 源码阅读过程中看到了spring的封装层次和引用的类，工具...学习

          3.设计思考点、注意点以及结合选型后代码中需要控制哪些。外部框架需要设置什么
                1.CacheManager  设计cache需要注意什么
                2.RPCManager    设计rpc需要注意什么

          4..优雅的整合 -  定位到 3.类  查看类定义、组合、继承、设计模式....
                         1.使用哪个注解 - 使用哪个springfactory - 后置处理器 - 从spring上下文(线程上下文、自定义上下文)中获得哪些东西和这里进行柔和
                             实现https://www.cnblogs.com/SimpleWu/p/12112351.html
                             所以必须了解spring的整个结构以及扩展点、注解、参数.. 系统性就和学习前面模块一样而不是片解。在不段使用学习中完善

                                        注解：https://blog.csdn.net/u010648555/article/details/76299467 + https://blog.csdn.net/weixin_37490221/article/details/78406810
                                                 @ComponentScan, @ConfigurationPropertiesScan, @EntityScan, or @SpringBootApplication
                                                 @Configuration  @ImportResource  @Import{ MyConfig.class, MyAnotherConfig.class })
                                                 @SpringBootApplication or @EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})--->通过查看源码知道配置哪些属性
                                                 @Autowired @Component, @Service, @Repository, @Controller
                                                 @SpringBootApplication = @EnableAutoConfiguration+@ComponentScan+@Configuration
                                                 @WebServlet, @WebFilter, and @WebListener can be enabled by using @ServletComponentScan.
                                            简单使用：Spring Boot中使用@Async实现异步调用 http://blog.didispace.com/springbootasync/
                                                      @EnableScheduling和@Scheduled的使用：https://blog.csdn.net/u014231523/article/details/76263304
                                                      Spring缓存注解 https://blog.csdn.net/wjacketcn/article/details/50945887
                                                      springmvc注解：https://www.cnblogs.com/leskang/p/5445698.html

                                ---spring注解没有解决，即通用的没有提供的，则通过源码bean扩展---
                                        扩展：https://www.cnblogs.com/xrq730/p/5721366.html <-- SpringMain.class （一定程度上因为自己的简单，所以赋值没有那么深究，可以从多个地方多种方式进行赋值）
                                        PropertyPlaceholderConfigurer
                                        AbstractRoutingDataSource(多数据源动态切换，子类可继承并重写determineCurrentLookupKey方法）
                                        聊聊spring的那些扩展机制:https://juejin.im/post/5ba45a94f265da0aa94a0d71
                                        ApplicationListener 扩展:https://juejin.im/post/5b7964d6f265da43412866c7

                                 --java 扩展 spi https://juejin.im/post/5af952fdf265da0b9e652de3

                        2.下面的“ 类 ”的东西规范-可扩展...{ 类结构 接口定义 - 设计模式 ....}
                             1>-实现版 - 流程图 这个是和需求紧密的，也必须是无差别正确的。 RuleManager.class + jaxbTest.class( 未进行类设计 )
                                     C:\Users\73699\Desktop\think\复杂业务架构思考\复杂性应对之道 - 领域建模
                                     C:\Users\73699\Desktop\think\极客时间\98-设计模式之美****
                                     C:\Users\73699\Desktop\think\极客时间\01-数据结构与算法之美

                                每个模块出流程外，涉及一些公共组件，比如流水号生成器

                                脑海中必须有 ‘ 流程图(业务从岗位 - 开发则从处理 、不一定时连续的，存在中断等待回调/信号) - 甬道图() - 时序图(当多个系统之间频繁交互 - 异步 mq..) ’

                                当发现传递参数较多时，注意 ‘ 从不同角度抽象为bean - xxsearchBean - CacheInitBean - UserLogonBean  ’

                                - 规范性（命名 naming.class - 使用第三方类库简化代码 apache-guava ApacheCommonTest.class --查看该项目已有-->自己定义工具类 String../ MathUtil / beanUtil / MethodUtils/FieldUtils/Ref..）
                                        健壮性(前置校验-validate VolidateController、返回包装json-对象+responsebody、统一异常baseController/异常分支(流程图)return/break/try..catch-有时即使api没有抛出异常该调用又不是关键为了后面继续，或者说远程调用，都要进行catch转义
                                        /throws、边界( 数据结构、算法 )、日志、事务、切面) 风险(安全、注入)
                                                 事务：所谓的事务挂起其实就是一个移除当前线程、数据源活动事务对象的过程。
                                                 事务的本质其实是对数据库自动提交的关闭与开启，传播特性是Spring提出、实现、控制的概念，而隔离级别是对数据库实现的封装。
                                     C:\Users\73699\Desktop\think\高效实现思考

                                    - 可扩展(基本实现-父类、抽象类接口- 反射(spring RelectionUitls/classUtils...)+泛型+注解 、重构(属性、方法定义合理性 - 属性bean通过依赖、关联、静态、默认、spring..初始化
                                            构造、方法重载、this的使用)、设计模式 )
                                    - 可扩展(反射+泛型+注解 、重构、设计模式(中间层比如代理、委托..接口上升) ) 原则(简洁、易用、可读、可维护、高内聚松耦合..) - 思想(6大..) - 模式(设计模式) - 归范 - 单元测试 - 重构
                                            AnnotationUtils +  + XMLConvertUtil
                                                设计模式： 总体 - SpringMain  ---结合 naming.class

                                                        适配器 -
                                                        包装器  WrapperParameter  WrapperInputStream 类似于dto 、代替继承、核心、公共、不同维度、除了实现核心所有的this.xx.xx（）外，还提供该维度扩展方法
                                                                比如图形 -形状 扩展颜色。
                                                                实际思考过程：重新定义类copy - 继承父类会造成膨胀 - 引用作为属性(这种其他属性轻重和核心属性是由区别的)
                                                                比如eod任务类 除了核心service还有自己的日志系统和监控系统

                                              设计模式复合使用（https://www.runoob.com/design-pattern/design-pattern-intro.html  关联使用）
                                                        0.层设计     Bmain.java -父类..
                                                        0.初始化     Cmain.java   SpringbootAndSpringInit.java
                                                        0.定位      Emain.java   EMain2.java（通过接口vs注解定位）
                                                        0.资源获取   Fmain.java  CacheRunner.java -- shcpe   SpringContextUtil工具类和spring柔和获取其中信息
                                                        0.信息结构   Gmain.java  xml解析 json  oxm ojm  / BeanDesign /DataStructure/TableDesign/Context
                                                        0.安全性     Kamin.java  防重 -  加密(秘钥)-签名验签 Gmain.java 、sql、服务器端校验、前置校、 合法性...
                                                        1.门面-模板-策略-工厂  Amain.java
                                                        2.监听-模板-多线程-oxm  Hmain.java  Gmain.java
                                                                   监听：异步 详见2>性能 异步实现方式
                                                                   模板方法：AbstractDraftBuilder.java /AbstractCallBack.java/AbstractDraftParse.java 参考定位+信息结构xml
                                                                   ***这个实现模块是在0和1所有的基础上添加了2的东西***

                                                                   mq监听到消息后是否开启线程处理，处理时如何控制关系。如何控制顺序，如何控制一个类多个线程访问问题
                                                        3.委派(中介者)-责任链(拦截器过滤器)-io(tomcat/netty)   Jmain.java
                                                        4.状态机(状态模式/jbpm)-命令模式 [登记中心]  Imain.java
                                                        5.适配器 装饰 代理
                                                        6.享元 - 池化

                                        - 框架(利用已有框架api扩展 SpringMain 、 切面、自定义规则配置文件 studentRule -xsd )
                                                        1.事务补偿
                                                        2.事务切面  事务从db事务抽象而来

                                        - 平台（尽可能自动化(1.动态sql即通过if判断拼接条件,)，参数之间某种关系、事务补偿平台）

                               当耗时操作比如插库，并且插库前有逻辑规则，可以先放到临时表，启新线程处理

                            2>性能
                                1.异步 -(解耦) 异步编程思考(为什么使用线程处理 https://juejin.im/post/5a8fc6345188257a804aa956) 某个节点上异步，内部还是同步 (event - callback -listner)
                                      将接口拆成两个，异步返回、调用者再去查询结果
                                      回调实例 ，借助监听机制
                                   1> thread     SerialNumGenerator
                                        D:\Data\mySrc\MockFramework\src\test\thread\MainClass
                                        C:\Users\73699\Desktop\think\极客时间\极客 并发
                                   2>事件
                                        回调模式 -  监听器模式 - spring事件机制 - mq
                                        比起在发布者线程中new 线程更解耦 。业务逻辑上是异步的，且允许消费者自己订阅的
                                   3> mq
                                        AmqMsgContainerFactory.java

                                   4> netty NIO/AIO TODO:如何体现异步的 WHILE接收到 异步阻塞... 接口设计 - 异步转同步
                                        netty.java

                                     ---数据传输基础：序列化 Serializable.java---
                                     ---            传输协议
                               2.缓存        redis实现
                               3.批处理
                               4.压缩        压缩耗时 + 传输压缩数据耗时 + 解压耗时。压缩它的本质是资源的置换，是一个时间换空间，或者说是 CPU 资源换存储资源的游戏。提高写入和数据传输
                               5.业务流程优化
                                        1.数据结构调整  比如kafka就将从pageCache - 用户内存 - socket内存转为 pageCache - socket
                                        2.redis单线程处理模型设计
                               6.分段、分片、分库表　分组　设权限




                             3>单元测试 测试驱动开发  手术刀 准确定位  TestMain.class、VolidateControllerTest.class
                                   明确修改点 - 局部测试 - 联合测试( debug修改参数值 )
                                   bbsp 新需求变更导致商票流程不可使用 ==> 关联影响性饭一定要到位，修改之前一定要对涉及部分清晰。
                                                                  ==> 流程至少跑一边(各个场景、开发角度过滤是否对分支有必要)
                                                                  ==> 没有绑定nullPointException 本事还是对业务场景分析不够导致存在情况漏洞 见：processon

                                     开发 + 单元测试（逻辑的缜密） + code-review


                              4>代码提交 - 不仅仅是归范而且是对代码注意点的重构
                                    1.idea自带的Analyze
                                    2.alibaba归范 - 插件
                                    3.pwd归范     - 插件
                                    4....
                                    5.github clean code
                                    6.github effictive java
                                    7.github toBetter
                                    8.SubmitCheck
                                    9.重构书籍思考

                      ************************

             从官方-民间(不同的角度比如property-spring env ../构造方法、后置处理器、)-自己项目企业级 这个过程是渐进的 -- 所以高内聚低耦合 接口 门面的作用就出来了
                    就像java简单main和api一样，需要不断的演化熟练学习使用，其次是参考源码。 比如这里从springboot的application.p中可以知道配置property也就是注意点
                    这样我们在@bean中对这些必要的控制 结合场景 https://docs.spring.io/spring-boot/docs/2.3.0.BUILD-SNAPSHOT/reference/html/appendix-application-properties.html#common-application-properties

                    从Github搜索相关，借鉴别人的思路进行学习整合

                    TODO:对反射 结构.....

             这样才对接了真正的源码 ，开源项目整洁。合理。内聚


    3. 学习新的文档api,根据其设计对应的代码 比如票交所的规范，如何根据规范设计对应的代码 --> 转化比如将逻辑、算法等转化为对应的代码实现
        xml组装



     4>微服务
           拆分：https://www.cnblogs.com/aibabel/p/11214026.html
           治理：

3.源码
          阅读源码难原因 1.基础不够实践不够  2.不知道使用场景和问题(见得多了不同之间汇通) 3.实现-模式优雅
           体会其中的取舍，解决思路，技术的综合使用，反射使用
           spring：C:\Users\73699\Desktop\think\框架学习认识使用思考\spring  +  沽咆笔记
           /mybatis/dubbo/
           web中间件 C:\Users\73699\Desktop\think\极客时间\50-深入拆解Tomcat & Jetty/
           消息中间件 mq思考
           引擎：工作流/规则..

4.问题定位  性能优化  Perform 项目
    扩展idea远程调试同样可以连接远程服务器和这里监控一个道理。判断是数据问题还是程序问题，判断当前运行环境而无需dump后才看
    工具的使用任然要积极借助官方api
    启动应用后可以顺带查看日志信息是否启动成功，是否有报错信息 tail

    -1.心态
        不要一上来就乱了阵脚。瞎查
        要有自己的解决思路，判断别人提供的信息，而不是完全相信
        前提是你知道客户的操作在哪个页面，大概的流程
        不要因为你对整个系统不是那么明确，清晰就对这种解决思路。这种思路是放之四海都是可行的。一步一步。不要慌

    0.代码
        问题排查
        1.错误信息是啥
        2.错误日志是啥
        3.类中代码是哪一行。
        4.对应sql在数据库中查。测试环境hibernate console中sql语句。即条件不满足所以报该错。
        5.考虑日终-切面等边缘性东西。配合解决

    通过soapui进行测试
    通过创建单元测试类，debug修改进行测试从而屏蔽前台，并且可以灵活对数据修改
    通过get查看调用  call / 通过set 查看塞入..逆向思维
    调用哪些系统，提供了哪些调用。主要业务流程中
    6H2w

    1.outOfMemory
    2.空间不足 app / db 表空间
    3.thread deadlock
    4.table lock
    5.mq block
    6.network 抖动
    C:\Users\73699\Desktop\think\性能+生产问题思考

