package com.pattern.j;

/**
 * 注意体会设计模式在解决场景方面微妙的不同侧重点
 *1.委派模式，是指什么呢？从字面含义理解，委派就是委托安排的意思，委派模式就是在做具体某件事情的过程中，交给其他人来做
 * ，这个事件就是在我的完整链路上的一部分，但是复杂度较高的情况下或者我不想做的情况下，完全可以委派给另一个类来处理，
 *  只要这个结果是符合我的预期的就可以（相当于填空）。---> 侧重map处理类map就是映射关系。调用者直接相关的就是dipatcher
 *  而无需进来后进行if判断   。 boss - leader - worker
  模板模式与委派模式的区别：模板模式更关注步骤，公共部分会放在模板的骨架步骤中完成，针对子类可能会有特殊的一些操作就可以
        在特定步骤中重新实现，从模板模式中能够看到清晰的过程步骤。
  代理模式与委派模式的区别：代理模式就是这个事情就根本不是我做的，但是我只能提供其中‘ 关键的一些信息，其他的周边或者在此基
        础上的扩展都可以交给其他人来做，完整的一个问题 ’，能够得到解决（这是目前理解到的代理模式，后续如果有更新，会重新对这里进行修改）
 *
 *
 * 2.资源定位 Emain 将map方到context在使用地方进行调用vs这里转发类 因为委派用于调用者是固定的。而不像前者可能从
 *           任意地方进行map数据获取
 *
 * 3.SelvletDispatcher.java
 *
 * 4.interceptor filter responseChain  hander -- ParamRuleCheckImpl.java 抽象类
 *  责任链设计模式（Chain of Responsibility）的应用有：Java Web中的过滤器链、Struts2中的拦截器栈。
 *  二者侧重不同 . 过滤器通过if嵌套if,并于不满足的不管  拦截器通过return不满足if分支
 *
 *  一个纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又 把责任向下传的情况。
 　　在一个纯的责任链模式里面，一个请求必须被某一个处理者对象所接收；在一个不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。
 *  *
 *  演变过程：https://www.cnblogs.com/Free-Thinker/p/4139306.html
 *  tomcat 中使用
 *
 *
 * 5.IO
 *      Serializable -- Netty
 *
 */
public class Jmain {



}
