package com.redis;

/**
 * 缓存设计注意事项：
 *
         1.缓存
         1.场景/哪些数据/是否提升性能
         采用 @Cacheable 注解的方式缓存的命中率如何？或者说怎样才能
         提高缓存的命中率？缓存是否总能返回最新的数据？如果缓存返回了过期的数据该怎么办？
         2.一致性/时间点/高可用/异常-数据丢失、连续 rdb/每天从新开始-过期时间 vs 一直/
         1.读写缓存  程序写入pageCache-异步磁盘同步 系统问题操作系统保证写入，断电丢失  kafka通过多个副本解决这种丢失
         2.读缓存    从磁盘获取数据写入缓存  高并发场景下：你是选择同步还是异步来更新缓存呢？如果是同步更新，更新磁盘成功了，但是更新缓存失
         败了，你是不是要反复重试来保证更新成功？如果多次重试都失败，那这次更新是算成功还
         是失败呢？如果是异步更新缓存，怎么保证更新的时序？

         解决方案：分布式事务 vs 定时将磁盘数据同步(不及时) - 全量 vs 增量   vs 过期
         转账(不适用缓存或者分布式强一致性)      后两者比如邮件、微信头像

         一定要合适的场景使用，不要死扣强一致性  人生也是这样要审时度势
         2.在内存有限的情况下，要优先缓存哪些数据，让缓存的命中率最高  - 缓存穿透 - 缓存置换  - 策略（命中率最高的置换策略，一定是根据你的业务逻辑，定制化的策略 -  LRU 算法 - 位置权重）



       缓存在架构设计中占有重要地位。缓存在提升性能中也扮演重要的角色。常见的有对资源的缓存，比如数据库连接池、http连接池，还有对数据的缓存等。
       缓存的设计可复杂也可简单，但是需要考虑的点却很多。

            1.缓存对象
                设计缓存的时候一定要考虑的是，缓存的对象是什么，缓存哪些对象。缓存对象一定是热数据，也就是频繁被访问。把对象加载到内存是以牺牲内存为代价的，如果缓存的对象不经常访问，
                那么就是在浪费内存，并且不但不会提升性能，还会因为命中率低的原因降低性能。
                哪些数据应该放到缓存中？依据是什么？缓存数据是采用主动刷新还是过期自动失效？（实效性较低，比如活动．．．可以自动失效．定时刷新、仿真参数由于使用主动刷新）
                    1.字典表、配置类的数据   2.明显是热点数据的数据 菜单、经常查询的业务数据，比如....  3.接口 对外提供服务返回固定数据？  4.其余数据的评估
                    参考自：https://blog.csdn.net/hollis_chuang/article/details/105154086

            2.缓存的类型、大小 、缓存对象粒度、结构、对象序列化
                是否还要将数据放到map中呢？多台服务器就能明显知道map的同步问题，高访问不一致的情况。--分布式缓存redis(并不是说redis比map好)
                因为内存是有限的，所以缓存不能无限大，那么就要决定缓存多少数据以保证内存不被撑爆。
                由于大部分的web应用都会尽量做到无状态，以方便线性扩容
                一般来说，你可以采用对象属性在内存中的存储长度简单加和的方法来计算单个对象的体积，再乘以缓存对象的数量和预期增长
                （当然，这里边有一个热点数据的问题，这里就不细讨论了），大概得出需要使用的缓存空间
                    参考自：https://data.qq.com/article?id=2879
                key设计规则：https://cloud.tencent.com/developer/article/1551803

            3.缓存一致性
                缓存一致性是必须要考虑的点。很多缓存设计都忘记了这一点，导致在使用缓存的时候经常返回过期数据。数据在更新的时候，缓存可以采用如下几个策略
                    1.将缓存中的数据设置为无效或者删除，再次查询的时候重新去数据库查询并更新缓存；这段时间的查询落到数据库上
                    2.更新数据时，先更新缓存，再更新数据库或者先更新缓存之后异步刷新到数据库 vs 先更新数据库，在更新缓存； 参考： https://blog.csdn.net/qq_33999844/article/details/81531461
                    3.直接更新数据库，缓存定期去数据库同步最新数据，这种方式需要容忍一定时间内的不一致。
                缓存刷新策略一定要明确。作者本人在工作中遇到过这种情况：更新数据的接口有两个，其中一个更新缓存后更新数据库，另一个直接去更新的数据库，
                由于没有同步机制，导致总是偶现数据不一致的情况，而且只能重启来规避。

            4.缓存在哪里
                对于缓存数据的存储位置也是需要考虑的。如果是分布式系统或者近期会重构成分布式的系统，缓存需要集中存储，比如使用redis做缓存。
                如果是单机系统，最简单的方式就是缓存到内存中。缓存的存储位置的访问一定要快于数据的存储位置，不然缓存就没有意义了。

            5.缓存流程
                 架构：缓存设计
                 缓存流程 ：参考图：https://www.toutiao.com/i6684499505179525640/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1585627214&app=news_article&utm_source=weixin&utm_medium=toutiao_android&req_id=2020033112001301013109819653035943&group_id=6684499505179525640
                            当前系统放入总量少，不存在hit问题，只要在缓存都命中。也不会 '****动态在缓存池中轮换**** '.其实这也是和过期时间关联的，这里没有过期时间一说--模拟器
                            没有什么刷新-命中-策略-过期时间
                            也真是这个，启动写入缓存，停机需要清空缓存吗？ 启动使用putifAbsent....而不是put操作，避免多份同类型的缓存。，禁止全部清空缓存

            6.经典缓存问题
                1.缓存穿透
                    缓存穿透是指客户端访问即不在缓存中的数据又不在数据库中的数据。这种访问过多会导致数据库挂掉影响正常访问。
                    对于这种问题，可以在数据访问前做校验，过滤掉不存在的数据访问，必须不合法的查询字段或者使用布隆过滤器，筛选掉不存在的数据；也可以将不存在的数据在缓存中建立空值缓存。
                    布隆过滤器:https://zhuanlan.zhihu.com/p/43263751

                2.缓存击穿
                    缓存击穿是指客户端访问不在缓存中但数据库中存在的数据。如果对某个key的访问量很大，这个时候缓存过期了，那么就会有很多的访问漏到数据库层面去访问数据。
                    这个问题可以采用如下方法解决：热点数据常驻缓存；访问在缓存中没有拿到数据，在需要去数据库中访问数据时加锁处理，只漏过一个访问去数据库查询数据，并将数据更新到缓存，
                    其他访问加锁失败，后续从缓存中取数据。

                                 SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。在redis2.6.1之前版本未实现setnx的过期时间，所以这里给出两种版本代码参考

                                 public String get(key) {
                                 String value = redis.get(key);
                                 if (value == null) { //代表缓存值过期
                                 //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db
                                 if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  //代表设置成功
                                 value = db.get(key);
                                 redis.set(key, value, expire_secs);
                                 redis.del(key_mutex);
                                 } else {  //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可
                                 sleep(50);
                                 get(key);  //重试
                                 }
                                 } else {
                                 return value;
                                 }
                                 }

                3.缓存雪崩
                    缓存雪崩是指大量的key过期，导致访问落到数据库上。这个问题的解决方法如下：
                            1.每个缓存数据设置不同的缓存时间，避免大量的缓存同时过期；
                            2.添加的节点预热。在需要添加缓存节点的时候，先做缓存预热，避免大量访问未命中的情况；
                            3.对于热点数据的判断采用延迟的策略。在访问缓存中不存在的数据的时候，不直接将它设置成最热数据，
                              而是设置到缓存数据按热度排序中间的位置，避免某一时刻大量访问冷数据导致热数据被剔除缓存的情况。

            7.建议
                    不建议在架构设计的最初阶段就采用缓存。首先，采用缓存容易掩盖一些问题，比如‘业务逻辑’导致的性能低下在由于缓存的存在在初期不容易暴露；
                    再有就是在最初阶段有的时候很难去判断什么是热数据什么是冷数据，需要缓存什么；如果已经确定要在系统中引入缓存那么一定要考虑好上面的几点。

 *
 */

public class CacheManager {
}
