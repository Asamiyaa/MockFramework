package com.msg;

/**
 * *          1.kafaka高性能：全异步化的线程模型、高性能的异步网络传输、
 自定义的私有传输协议和序列化、反序列化
 批处理
 顺序读写：将每批消息写入对应的文件
 pageCache
 zeroCopy    直接从 PageCache 中把数据复制到 Socket 缓冲区中，这样不仅减少一次数据复
 制，更重要的是，由于不用把数据复制到用户内存空间，DMA 控制器可以直接完成数据复
 制，不需要 CPU 参与，速度更快。

 2.解决一致性 防丢失性的写法 - 代码落地
 *
 *
 *
 *          1.使用场景
 *              1.非及时   2 弱一致性(订单删除)
 *
 *          2. 一致性       分布式事务   --- ACID 本地数据库事务 。从一致性上引入弱一致性、顺序一致性、最终一致性...进行取舍(没有银弹)
 *                         两阶段提交、TCC... ->异常：事务补偿（使用序列化将当时的场景保存再反..处理 -保护小内存.）、重试、异常抛出.. 手工处理-冲正
 *
 *                          1，调用账户失败，可以在异步callBack里执行通知客户端的逻辑；
 2，如果是第一次失败，那后面的那一步就不用执行了，所以转账失败；如果是第一次成功
 但是第二次失败，首先考虑重试，如果转账服务是幂等的,可以考虑一定次数的重试，如果
 不能重试，可以考虑采用补偿机制，undo第一次的转账操作。  …

 *             可靠性       发送、接受创建拦截器注入序号、分区判断消息是否连续
 *                         生产阶段：client-broker 确认响应机制 正确处理返回值/或者捕获异常  --异步 回调处理返回值
 *                         存储阶段：至少两个节点同步、复制刷盘/磁盘落地 再返回确认    -- 引入管理节点后，管理节点是否集群呢 集群后如何保证高可用 多少个副本写入算成功写入呢？
 *                         消费阶段：先存储库，发送确认消息。执行完消费业务逻辑后发送消息确认
 *                      问题：如果回复确认报文在网络中丢失，如何处理？
 *
 *        *****  幂等是一致性的一个子分支 *****
 *            重复消息--幂等 由于重试机制导致重复   at least once 至少一次(可靠性导致允许重复)  最高：exactly once 很难
 *                           --> 任意多次所产生的影响均与一次处理的一样(把账户余额设置为100元 vs ....加100元)  --> 支付接口
 *                                  1.数据库约束
 *                                          1.转账流水表  转账id-用户id-金额 为转账id设置唯一约束
 *                                          2.前置条件比如如果当前为500元，则加100  --> 版本号
 *                                   2.记录并检查操作 全局发送id、先去判断是否已执行
 *                                          但是在分布式系统下、原子性很难保证 --> 分布式锁 、 分布式事务
 *                                   3.状态机
 *
 *              消息积压    发送端：发消息之前业务逻辑 +  并发数量(时延要求高) + 批量大小(吞吐量要求高)
 *                          消费端：.......            +  consumer和分区同步   / onMessage中将消息保存在内存中返回，在启动多线程处理业务逻辑->丢消息
 *                                  出现情况：在分析.快速解决增加consumer数量  消费错误 、重复消费、死锁
 *
 *              顺序性   分布式下如何保证发送到统一处理机？hash算法，指定队列发送  /  队列取模
 *                          全局有序 --> 局部有序 账户流水
 *
 *            3.队列实现柔和技术
 *
 *            4.socketmq ：productor  / consumer 代码实现 查看 mq 20/21/23、25事务节  - 带着问题去看具体代码实现上面的具体实现  nameServer(路由信息)= 注册中心  brocker  -- 代码的整洁性
 *                      reocket路由寻址 vs  kafka通过zookeeper分布式协调  ZooKeeper 作为一个分布式的协调服务框架，主要用来解决分布式集群中，应用系统需 面对的各种通用的一致性问题。
 * 它提供了一个分布式的存储系统，数据的组织方式类似于、UNIX 文件系统的树形结构。ZooKeeper 来实现业务集群的快速选举、节点间的简单通信、分布式锁等很多功能。
 3分布式系统中一些需要整个集群所有节点都访问的元数据，比如集群节点信息、公共配置信息等，特别适 合保存在 ZooKeeper 中。
 事务：
 Kafka 的事务解决的问题和 RocketMQ 是不太一样的。RocketMQ 中的事务，它解决的问题是，确保执行本地事务和发消息这两个操作，要么都成功，要么都失败。并且，RocketMQ 增加了一个事务
 反查的机制，来尽量提高事务执行的成功率和数据一致性。
 Kafka 中的事务，它解决的问题是，确保在一个事务中发送的多条消息，要么都成功， 要么都失败。注意，这里面的多条消息不一定要在同一个主题和分区中，可以是发往多个主
 题和分区的消息。

 Kafka 在内的几个常见的开源消息队列，都只能做到 At Least Once，也就是至少一次，保证消息不丢，但有可能会重复。做不到Exactly Once。
 1. completableFuture.thenCompose  completableFuture<Void> void是真实的返回类型，xxfure是线程级别的类型。从中获取信息
 *                      同步：线程创建限制 / 线程满后执行时间=等待时间+平均每笔消耗时间

 */
public class RPCManager {
}
