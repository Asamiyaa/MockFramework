package com.StructureAlgorithm.sort;

import java.util.Arrays;

public class BubbleSort {
   
	/**
	 * date:20180502
	 * autor:ywj
	 * 冒泡排序 又名  扫描交换，直至全序 。
	 * 原理：依次比较相邻的两个数，将小数放在前面，大数放在后面。
	 * 即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，
	 * 将小数放前，大数放后。至此第一趟结束.将     "最大的数"     放到了最后。
	 * 在第二趟：仍从第一对数开始比较（因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数），将小数放前，大数放后，
	 * 一直比较到倒数第二个数（倒数第一的位置上已经是最大的），第二趟结束，在    "倒数第二"    的位置上得到一个新的最大数
	 * （其实在整个数列中是第二大的数）。如此下去，重复以上过程，直至最终完成排序。
	 * 
	 * 实现思路：用二重循环实现，外循环变量设为i，内循环变量设为j。假如有n个数需要进行排序，则外循环重复n-1次，内循环依次重复n-1，n-2，...，1次。每次进行比较的两个元素都是与内循环j有关的，它们可以分别用a[j]和a[j+1]标识，i的值依次为1,2,...,n-1，对于每一个i，j的值依次为0,1,2,...n-i 。
                  设数组长度为N：
                      1．比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个数据交换。
                      2．这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。
                      3．N=N-1，如果N不为0就重复前面二步，否则排序完成。
	 */
	 static Integer[]  array = new Integer[]{2,3,7,4,4,4,1,9,5} ;

	 public static  void bubbleSort(){
		 for(int i = 0 ; i< array.length -1 ; i++ ){                       //n个数需要进行排序，则外循环重复n-1次   --> 每次外循环得到一个“次大”的数值。i表示已经排序完成的数量
			for(int j = 0; j < array.length - i  - 1 ; j ++){                //每次循环内对比“相邻元素”这种对比就是小循环    --> 大循环和小循环之间关系 这种关系是为了  "排除已经排完的有序的大数" (并不是都存在内外循环关系的)
			           if(  array[j] > array[j+1]  ){                           //如果相邻的两个元素前者大于后者(默认从小到大排序)，则交换，否则，比较下一组。
			        	   swap(j , j+1 );
			           }
			}  
		}
		 System.out.println(Arrays.toString(array));
	}
	//1.ava.lang.ArrayIndexOutOfBoundsException: 注意这里的array.length -1 ； 因为比较次数是”剩最后一位时已经无需再比较了。“所以这里时长度减一， 而和 < 无关
	//2.循环完成后要展示出来数组的值。
	 

	 private static void swap(Integer i1, Integer i2) {
              	int  temp  = array[i1] ;
              	array[i1] = array[i2] ;
              	array[i2] = temp ;
	}

	public static void main(String[] args) {
		 //bubbleSort() ;
		 //bubbleSort2() ;
		bubbleSort3() ;
	}
	/**
	 * 改进：如果值时相等的呢？  = 换不换都一样   --> 这里判断“不想要”的情况
	 *           如果可以更早的判断出前面有序的呢？
	 *                   性能分析：若记录序列的初始状态为"正序"，则冒泡排序过程只需进行一趟排序，在排序过程中只需进行n-1次比较，且不移动记录；
	 *                   反之，若记录序列的初始状态为"逆序"，则需进行n(n-1）/2次比较和记录移动。因此冒泡排序总的时间复杂度为O(n*n)。
	 */
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// public static  void bubbleSort2(){
	//	 //for(int i = 0 ; i< array.length -1 ; i++ ){   这里是否需要i来控制  --> 需要  因为i这里缩小排序处理的范围。 -->这里可以通过while（true）。。来限定呀  错误。这里while实质时对flag的判断和监控而不能兼具循环。              
	//	boolean sorted = false ;                                      //无序推论
	//	while( !sorted ){                                                   
	//		for(int j = 0; j < array.length   - 1 ; j ++){         //8 9 7 10 - 8 7 9 10- 7 8 9 即：
	//		           if(  array[j] > array[j+1]  ){                      //2,3,7,4,4,4,1,9,5
	//		        	 //  sorted = false ;                                  //false说明上一次发生了交换 ，上一次交换完后是否有序呢？
	//		        	   swap(j , j+1 );
	//		        	   sorted = false ;
	//		      } 
	//		}   
	//		if(sorted){break ; }                                             //无法展示  --> debug
	//	}
	//	 
	//}
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	public static  void bubbleSort2(){
		boolean flag = true  ;                                          //无罪推论 
		while( flag ){                                                         //不对循环起作用，只对“提前终止” 起作用。
			flag = false ;                                                      //************                     
			for(int i = 0 ; i< array.length -1 ; i++ ){  
				for(int j = 0; j < array.length  -i  - 1 ; j ++){  
					if(  array[j] > array[j+1]  ){    
						 swap(j , j+1 );
						 flag = true ;                                         //修改成员变量
					}
				}
				//走完一轮 ；判断sorted情况。是否需要走下一轮  --> i  
				   if(!flag){
					   break ;           //跳出for循环 ，进入while
				   }
			}
		}System.out.println(Arrays.toString(array));
	}
	//该问题再尝试过程中多次无法协调 ； 矛盾   ； 解决是：在while循环内对声明的flag再次赋值，初值为true ；是为了进入while循环。

    //如果一个序列后半部分为有序，前半部分为乱序 ； 前两者算法是无法及时 “发现” ；导致多次无用的比较 即使没有交换
	//识别序列中片段有序，跳转 ，比较  ，跳转   .......  --> 局部冒泡*
	/**
	 * 冒泡排序中，一趟扫描有可能无数据交换，也有可能有一次或多次数据交换，在传统的冒泡排序算法及近年来的一些改进的算法中，
	 * 只记录一趟扫描有无数据交换的信息，对数据交换发生的位置信息则不予处理。为了充分利用这一信息，可以在一趟全局扫描中，
	 * 对每一反序数据对进行局部冒泡排序处理，称之为局部冒泡排序。局部冒泡排序与冒泡排序算法具有相同的时间复杂度，并且在正序和逆序的情况下，
	 * 所需的关键字的比较次数和移动次数完全相同。由于局部冒泡排序和冒泡排序的数据移动次数总是相同的，
	 * 而局部冒泡排序所需关键字的比较次数常少于冒泡排序，这意味着局部冒泡排序很可能在平均比较次数上对冒泡排序有所改进，
	 * 当比较次数较少的优点不足以抵消其程序复杂度所带来的额外开销，而当数据量较大时，局部冒泡排序的时间性能则明显优于冒泡排序
	 * 。对于N个无序数据，我们在进行一趟冒泡排序时，如果第k个数据和第k+1个数据逆序，那么对第k+1个数据进行一趟向前的冒泡排序，
	 * 使其移动到合适的位置，也就是说让前面k+1个数据调节为正序。因为这种冒泡法只对前k+1个数据冒泡处理，所以我们称它为——局部冒泡
	 */
	public static  void bubbleSort3(){
		for (int i = 0; i < array.length -1; i++){    //最多做n-1趟排序  
	         if(array[i]>array[i + 1])  
	         {  
	                int j = 0;                    //i=1 假如  第二位数字大于第三位数字  array[1] > array[2]
	                int temp = 0;        
	                 j = i + 1;                    //j来具体操作交换
	                                                  //从左向右扫描，发现前者大于后者，则将前面的所有进行重排序。接着进行下一个比较 ，没有内外层。--> 跳过了后者大于前者的情况。
	                 while(j > 0 && array[j] < array[j - 1])  
	                        {  
	                             temp=array[j];  
	                             array[j]=array[j - 1];  
	                             array[j - 1] = temp;  
	                              j--;   
	                        }  
	          }  
	  }	System.out.println(Arrays.toString(array));
}
}
