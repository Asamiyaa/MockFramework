package com.Normalization;

/**
 *减小代码的体积

 提高代码运行的效率

 代码优化细节

 1、尽量指定类、方法的final修饰符

 带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50% 。

 2、尽量重用对象

 特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。

 3、尽可能使用局部变量

 调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。

 4、及时关闭流

 Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。

 5、尽量减少对变量的重复计算

 明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作：
    for(int i = 0 ;i <list.size(),i++){}
    for(int i = 0,int length = list.size();i<length;i++){}
 6、尽量采用懒加载的策略，即在需要的时候才创建
 7、慎用异常

 异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace的本地同步方法，fillInStackTrace方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。
 8、不要在循环中使用try…catch…，应该把其放在最外层

 除非不得已。如果毫无理由地这么写了，只要你的领导资深一点、有强迫症一点，八成就要骂你为什么写出这种垃圾代码来了。
 9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度

 比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例：

 （1）StringBuilder // 默认分配16个字符的空间

 （2）StringBuilder(int size) // 默认分配size个字符的空间

 （3）StringBuilder(String str) // 默认分配16个字符+str.length个字符空间

 可以通过类（这里指的不仅仅是上面的StringBuilder）的来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么：

 （1）在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间；

 （2）把原来的4096个字符拷贝到新的的字符数组中去。

 这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。

 10、当复制大量数据时，使用System.arraycopy命令

 11、乘法和除法使用移位操作
 for(var = 0 ; var <1000;var+=5){
        a=va*8;
        b=va/2;
 }

 for(var = 0 ; var <1000;var+=5){
        a =var << 3;
        b = var >>1;
 }
 12、循环内不要不断创建对象引用
    for(int i =1 ;i<=count ;i++){
        Object obj = new Object();
 }
 这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：
 Object obj ;
 for(int i =1 ;i<=count ;i++){
     obj = new Object();
 }这样的话，内存中只有一份Object对象引用，每次new Object的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。

 13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList

 14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销

 15、不要将数组声明为public static final

 因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变。

 16、尽量在合适的场合使用单例

 使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：

 （1）控制资源的使用，通过线程同步来控制资源的并发访问

 （2）控制实例的产生，以达到节约资源的目的

 （3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信

 17、尽量避免随意使用静态变量

 要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如
 此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止

 18、及时清除不再需要的会话

 为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate方法清除会话。

 19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历

 这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：
 foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。
 20、使用同步代码块替代同步方法

 这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。

 21、将常量声明为static final，并以大写命名

 这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量。

 22、不要创建一些不使用的对象，不要导入一些不使用的类

 这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容

 23、程序运行过程中避免使用反射

 关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。

 24、使用数据库连接池和线程池

 这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程

 25、使用带缓冲的输入输出流进行IO操作

 带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率

 26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList这个，理解ArrayList和LinkedList的原理就知道了

 27、不要让public方法中有太多的形参

 public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：

 1、违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合

 2、参数太多势必导致方法调用的出错概率增加

 至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参。


 32、公用的集合类中不使用的数据一定要及时remove掉

 如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。

 33、把一个基本数据类型转为字符串，基本数据类型.toString是最快的方式、String.valueOf次之、数据+””最慢
 34.使用entrySet遍历map
 35.将try..catch..finally资源关闭分开
        try{xx.close ;yy.close} catch..可能导致第一个关闭异常，后续无法关闭
        --> 每个资源单独try..catch ...
 36.2. 应该使用 Collection.isEmpty() 检测空

 使用 Collection.size() 来检测空逻辑上没有问题，但是使用 Collection.isEmpty() 使得代码更易读，并且可以获得更好的性能。任何 Collection.isEmpty() 实现的时间复杂度都是 O(1) ，但是某些 Collection.size() 实现的时间复杂度可能是O(n)。
 集合初始化尽量指定大小

 37.java 的集合类用起来十分方便，但是看源码可知，集合也是有大小限制的。每次扩容的时间复杂度很有可能是 O(n) ，所以尽量指定可预知的集合大小，能减少集合的扩容次数。

 6.List的随机访问

 大家都知道数组和链表的区别：数组的随机访问效率更高。当调用方法获取到 List 后，如果想随机访问其中的数据，并不知道该数组内部实现是链表还是数组，怎么办呢？可以判断它是否实现 RandomAccess 接口。
  list instanceof RandomAccess .....内部数组实现，随机访问效率高
  ......................................链表实现...........低
 频繁调用 Collection.contains 方法请使用 Set

 在 java 集合类库中，List 的 contains 方法普遍时间复杂度是 O(n) ，如果在代码中需要频繁调用 contains 方法查找数据，可以先将 list 转换成 HashSet 实现，将 O(n) 的时间复杂度降为 O(1) 。
 ArrayList list = ...getList();
 for(){
   list.contains(i);
 }
 ---->
 set set = new HashSet(list);
 set.contains(i);

 10.不要使用集合实现来赋值静态成员变量
 private static Map<> map = new HashMap(){
     {
        put("a","a");
     }
 }
 private static Map<> map = new HashMap()
 static{
    map.put("a","a");
 }
 11.建议使用 try-with-resources 语句

 Java 7 中引入了 try-with-resources 语句，该语句能保证将相关资源关闭，优于原来的 try-catch-finally 语句，并且使程序代码更安全更简洁。
    try(BufferReader bf = new BufferReader(new FileReader(fileNmae))){}catch(){}

 21.禁止使用构造方法 BigDecimal(double)

 BigDecimal(double) 存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。

 22.返回空数组和空集合而不是 null

 返回 null ，需要调用方强制检测 null ，否则就会抛出空指针异常。返回空数组或空集合，有效地避免了调用方因为未检测 null 而抛出空指针异常，还可以删除调用方检测 null 的语句使代码更简洁。
 23.优先使用常量或确定值来调用 equals 方法
    a.equals(b) --可能空指针
    --->
    Objects.equals(a,b);
 .小心 String.split(String regex)

 字符串 String 的 split 方法，传入的分隔字符串是正则表达式！部分关键字（比如.[]()\|等）需要转义
 */
public class SubmitCheck {


}
