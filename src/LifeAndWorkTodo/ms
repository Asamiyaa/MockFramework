高级常见面试题：https://blog.csdn.net/Butterfly_resting/article/details/89637697

1.IO
    1.IO NIO 阻塞 同步 https://www.cnblogs.com/dolphin0520/p/3916526.html
    2.Netty  https://juejin.im/post/6844903703183360008
    3.tcp udp :https://blog.51cto.com/feinibuke/340272
    4.三次握手四次挥手
        http 的问题，为什么是无状态的，状态码，session，cookie，cookie 大小限制是多少

2.异步
    1.同步转异步 https://blog.csdn.net/qq_32447301/article/details/90322555
    2.concurrentHashMap使用场景及错误使用 https://blog.csdn.net/zero__007/article/details/49833819
        问题1：不清楚一个流程执行中哪些是原子的，哪些不是
           2：多个线程这种干扰到底存在几种，很乱，很多。
    3.SimpleDateFormat线程不安全：https://blog.csdn.net/csdn_ds/article/details/72984646

3.jdk
    1.hashMap和concurrentHashMap

4.collections
    1.集合中删除元素

5.算法
    1.各个数据结构选择  https://juejin.im/post/6844903633914445837#heading-2
    1.字符串反转 https://www.cnblogs.com/JohnTsai/p/5606719.html
    2.java 中 怎样才能打印出数组中的重复元素

6.设计模式
    1.adapter 充电器 为什么不直接引用接口而是需要适配，引用同样可以实现内部调用实现呀
    2.给我一个符合开闭原则的设计模式的例子
            策略模式，如果你需要一个新的策略，只需要实现接口，增加配置，不需要改变核心逻辑。一个正在工作的例子是
            Collections.sort() 方法，这就是基于策略模式，遵循开闭原则的，你不需为新的对象修改 sort() 方法，你需要做的仅仅是实现你自己的 Comparator 接口。

7.数据库
    1.索引 - hash B B+
    2.主从备份
    3.一条sql执行过程
    4.执行计划
    5.优化
    6.乐观锁 悲观锁

8.流程
    1.浏览器输入一个域名开始，到显示页面，中间发生了什么

9.业务难点


10.redis
    1.缓存 CacheManager.java -
    2.系统学习 Redis:https://juejin.im/post/6844904111205253134 + 命令+代码调用
    3.分布式锁 ：https://juejin.im/entry/6844903545339133959
    4.lua脚本  提高i灵活性将判断逻辑放到redis server端 而无需client
    5.Redis集群下的RedLock算法(真分布式锁) 实践  https://cloud.tencent.com/developer/article/1523004


************************************
分布式下问题(mq/dubbo不同解决方案)：
    1.分布式一致性等：Kmain AmqMsgContainerFactory(activemq) - DefaultProducercodeImpl
        D:\Data\mySrc\MockFramework\src\LifeAndWorkTodo\photo\rocketmq分布式事务半消息实现.png

    2.MQ消息最终一致性解决方案  https://juejin.im/post/6844903951448408071
        1.链路长，并且增加了网络，mq等其他组件导致一致性复杂(注意可能出问题节点)，所以增加操作状态 ：预发送、定时回查...
        2.代码需要如何保证ack判断 发送和消费都是如何在自己处理后发送呢？？？？
            https://www.cnblogs.com/wuzhenzhao/p/11504941.html  代码实现 先保存本地保证，返回消费成功给mq
            https://blog.csdn.net/qq_35362055/article/details/81560388
        3.整个流程 发送方保证+mq保证+consumer保证 = 一致性
        4.只保证通讯级别不保证业务级别，消费者抛出npe,那么事务是不一致的


11.rocketmq + 消息的组拼解析(xml/bj银行 head头每个字节代表什么..解析) + 接口归范的理解和编码
    1.《浅入浅出》-RocketMQ -扫盲 : https://juejin.im/post/6844904008629354504#heading-10
       mq场景 配置 使用：https://www.cnblogs.com/joylee/p/8916460.html
                       https://juejin.im/post/6844903696577331208

    十分钟入门RocketMQ：http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/
                      https://chestnutheng.cn/2019/09/04/rocketmq/

    2.默认配置
        1.rocketmq的重试队列和死信队列  https://www.jianshu.com/p/1281f7fee69c
        2.发送/消费 防丢失、顺序性、重复性是mq控制还是系统还是配合
          mq:可以保证顺序性和至少消费一次：RocketMQ  一个topic下有多个队列，为了保证发送有序，RocketMQ提供了MessageQueueSelector队列选择机制Hash取模法，
          MetaQ主要使用了拉模型，解决了顺序消息和海量堆积问题；Notify主要使用了推模型，解决了事务消息；

    3.源码 - 解决mq内部处理逻辑
        1.从RocketMQ源码了解其系统设计:https://juejin.im/post/6856205024717897742
        2.https://developer.aliyun.com/article/759659
          https://juejin.im/post/6856205024717897742
        3.RocketMQ源码解析：https://juejin.im/post/6844904166247104519

    4.设计模式
        1.通信层设计模式：https://zhuanlan.zhihu.com/p/103915220
        2.

    5.问题和调优
        队列堵了:  https://juejin.im/post/6844904199667318798
        消费消息是push还是pull？RocketMQ没有真正意义的push，都是pull，虽然有push类，但实际底层实现采用的是长轮询机制，即拉取方式
        为什么要主动拉取消息而不使用事件监听方式？
            事件驱动方式是建立好长连接，由事件（发送数据）的方式来实时推送。
            如果broker主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成消息在consumer端堆积过多，同时又不能被其他consumer消费的情况。而pull的方式可以根据当前自身情况来pull，不会造成过多的压力而造成瓶颈。所以采取了pull的方式。

        堆积时间过长消息超时了？
        RocketMQ中的消息只会在commitLog被删除的时候才会消失，不会超时。也就是说未被消费的消息不会存在超时删除这情况。

        追问：堆积的消息会不会进死信队列？
        不会，消息在消费失败后会进入重试队列（%RETRY%+ConsumerGroup），18次（默认18次，网上所有文章都说是16次，无一例外。但是我没搞懂为啥是16次，这不是18个时间吗 ？）才会进入死信队列（%DLQ%+ConsumerGroup）。

        面试题:https://www.cnblogs.com/javazhiyin/p/13327925.html


12.zookeeper 协调框架
    1.原理
    2.分布式锁


12.源码

13.dubbo、SpringCloud这块
    0.bilibili dubbo使用教程
    1.架构图(不同颜色的线代表调用暴露流程以及所属)
    2.时序图   https://blog.csdn.net/xinfei0803/article/details/80079613(源码时序图就像多个系统协作完成，我们的是不同的系统给比如额度信贷这里对象就是对这些的抽象 职责)
    3.源码：https://juejin.im/post/6844903799832707079
    4.spi
        1.为什么其他框架没有呢：dubbo除了提供多种配置选择外还自定义-替换，实现指定接口由如何让dubbo识别且这些替换是替换了
                            dubbo核心处理逻辑 --其他框架mybatis..等似乎没有替换核心
    5.面试题：
        1.简述服务暴露和引用过程
        2.集群容错几种 以及场景：https://juejin.im/post/6844903806841405454
          负载均衡：https://juejin.im/post/6844903806841405448
        3.如何异步转同步：https://juejin.im/post/6844903806845583374

    6.设计模式


14.maven
    1.打包
    2.依赖冲突

15.springboot
    1.启动加载
    2.starter
    3.时序图   --- spring
    4.整合
        1.mybatis:https://blog.csdn.net/qq_31156563/article/details/107448279


16.spring --专注于对象管理
    1.refresh()  1.beanFactory  2.bean- 创建图(判断缓存...)
            url:https://www.jianshu.com/p/32dacf644062
            D:\Data\mySrc\MockFramework\src\LifeAndWorkTodo\photo\spring初始化.png

        0.spring整合其他框架 -通过factoryBean接口注入   图片 将代理bean
            1.注册其他构造入参作为springbean ,即spring初始化之一(传统的Spring容器加载一个Bean的整个过程，都是由Spring控制的，换句话说，开发者除了设置Bean相关属性之外，是没有太多的自主权的。FactoryBean改变了这一点，开发者可以个性化地定制自己想要实例化出来的Bean，方法就是实现FactoryBean接口。)
                正常时通过解析为beanDefinition...现在是直接有我们来创建，通过此注册到spring
            2.factoryBean：解析过程：https://blog.csdn.net/zknxx/article/details/79572387
            3.查看改接口的子类有多个，比如Activemq.... 区分@Bean 只是可以定义入参，创建对象还是由spring完成

        1.jdbc统一管理



    2.扩展接口 属性....都是在实例化的时候完成的  ***其中的图：https://www.jianshu.com/p/a854e23d88dd
        0.实例化 调用无参构造器，成员属性... 这里无参中只能做自己对象简单事，利用spring下面接口可以获取整个容器信息
        1.aware 对象初始化时需要依赖‘感知’  -- beanName、BeanFacotry、ApplicationContextAware
        2.beanPostProcessor 是全局配置，每个bean初始化时都查看改列表。作为aop...等全局配置。。前后置(初始化下面)处理 postProcessorBeforeInitialization()....
           aop场景：https://blog.csdn.net/baidu_20876831/article/details/78956220
        3.InitializingBean和init-method 属性设置完成后做的事情，比如方法调用，cache初始化 --springboot的ApplicationRunner
          afterPropertiesSet-ActiveMqConnectionFa...
          destroy...释放信息...
        4.3之后执行2的后置处理

    3.循环依赖 初始化过程中有一步设置对象属性：通过三级缓存解决  ：https://cloud.tencent.com/developer/article/1497692

    4.spring事务：为了解决业务层方法之间互相调用的事务问题 - 除bean之外另一层面 - a()-->b()各自情况笛卡尔积 [aop+db]
           https://juejin.im/post/6844903608224333838
           PROPAGATION_REQUIRED ：统一一个事务
           PROPAGATION_REQUIRES_NEW:新开启一个事务 即当前方法的执行不影响主流程，比如保存日志(多个表才有事务意义)....
           PROPAGATION_NESTED：嵌套事务 其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。
                               部分回滚

           回滚规则：事务只有遇到运行期异常时才会回滚，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。(场景)

           源码：DatasourceTransactionManager
                1.整合connection -> db.. 2.实现initialzingBean 校验设置  3.写的整洁，高内聚低耦合  4.xxxholder

           事务失效场景：

           分布式事务：

    5.spring设计模式
        1.

    6.池化 https://blog.csdn.net/zjpopo/article/details/101099298 只有真正涉及到网络-连接池、线程资源-线程池  vs 单例
        1.本质就是创建一个list..将new Connection(xx,xx,....) 对象创建了放进去 -- GenericObjectPool common-pool


17.mybatis - menu.TableDesign - 《effectiveSQL》-
    1.${}/#{} https://www.cnblogs.com/shar-wang/p/11614722.html
     - 动态sql :if、choose、when、otherwise、trim、where、set以及foreach  https://blog.csdn.net/u012702547/article/details/55105400
            - 本质就是将代码中对sql条件的判断下沉到sql编写上。最主要的if和foreah-批处理 batch

    1.源码 :https://my.oschina.net/zudajun?tab=newest&catalogId=3532897
        1.SqlSessionManager 1.jdk动态代理 没有想的那么复杂，就是将调用逻辑进行（增强-aop-事务)，这里对sqlSession 判断有无 - 动态代理：https://my.oschina.net/zudajun/blog/666223
           xxxTemplate -xxmanager - defaltsql...  只有defaultxxx进行真正mappedStatement真正对配置文件
           解析就像spring中的beanDefinition一样 。赋值给executor执行
        2.threadLocal ?? 如何保证线程安全的
        3.executor
        4.方法不支持重载，不同的namespace下id不同get有问题，因为mybatis同一key存放了两份其中一个是全类名 使用绑定Mapper接口调用方法，因为它总是转换为full name调用。（Mybatis最佳实践，推荐）
        5.incomplete对于元素在当前元素下面时，状态，返回来设置。类似于spring的三级缓存  -parsePendingElement
        6.TypeHandler - converter...

    2.聊聊MyBatis缓存机制 :https://tech.meituan.com/2018/01/19/mybatis-cache.html
    3.面试题：https://my.oschina.net/zudajun/blog/747682
    4.设计模式


18.springmvc
    1.

19.多线程
    1.代码行之间、api操作期间如何判断是否是原子操作，不是的话不是都可以笛卡尔积吗？那样混乱如何写出正确的代码呢？
    2.