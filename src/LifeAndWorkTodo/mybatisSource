 
- 就像logback-spring.xml是log和spring的融合一样，mybatis和spring融合就是这个。所以思考 ===>  切入点 <=== 比如取spring中变量到myatis中进行判断。


	1.@mapper修饰mapper接口
	2.通过 Mapper.xml中的<mapper namespace="">来完成xml是实现和mapper接口的关联
	3.在任意spring扫描的类上(启动类vs@configration)加上mapperscan使spring的MapperScannerRegistrar解析为springbean
	4.dbconfig可以配置@mapperscan / datasouce <--- selector不同选择不同的数据源 / location - 多个文件比如单独的common.xml + body.xml...
	5.在配置基础上，加入spring注解@conditional...来灵活配置


 1.事务 -> db事务 
 	1.https://my.oschina.net/fifadxj/blog/785621
 	  https://www.jianshu.com/p/6b275553b54f

 	  本质都是通过connection操作数据库完成，所以这是数据库概念api  <-- checkpoint机制 ---> . 特别是spring的传播行为

 2.session资源 =  该对象持有的其他对象引用。 属性越多，越庞大 比如这里的configration 其实这里的sqlsession持有了所有db操作的信息。

 3.db层面sql逻辑 <if...--加载解析转化为代码逻辑--代码逻辑是什么样的呢？如何维护？ xml解析 - 注解解析 - 并维护关系  
 		https://www.cnblogs.com/fangjian0423/p/mybaits-dynamic-sql-analysis.html *****
 		可以用来扩展 动态 xml和解析 <======= 借鉴


	   配置多，是因为底层帮你做了。比如缓存，转换，刷新，timeout ..具体查看XMLStatementBuilder.parseStatementNode查看可以的配置信息。
	   通过简单的配置即可实现，本来自己需要代码去控制的。这也是框架做的。将需要的东西封装起来并提供简单暴露

 4.作用于db,而又融合于spring  
 		1.使其成为spring的bean 
 			Spring Boot中Mybatis启动过程概述  == https://my.oschina.net/yangjianzhou/blog/3022258
 			   1. 两种方式：	
 		    	   MapperScannerConfigurer继承了beanfactorypostprocessor  vs MapperScannerRegistrar 区别：一个是注解一个xml：https://www.wetsion.site/mybatis-mapper-register-autowire.html
				   factorybean 写入sqlsessionfactory - 加载xml配置信息 -sql信息 
				   问题：这些不同形式的位置写入spring的区别是什么？
			    2.Spring finishBeanFactoryInitialization  https://www.cnblogs.com/ZhuChangwu/p/11755973.html

		2.
	   		Spring钩子方法和钩子接口的使用详解:https://www.jianshu.com/p/e22b9fef311c

	  	3.  spring中那么多注解是如何和处理类绑定的？？？

	  	4.如何让注解和实现类关联起来
	  		1.spring4.1.8扩展实战之八：Import注解 https://cloud.tencent.com/developer/article/1438658
	  		2.https://wenku.baidu.com/view/41338d73ac02de80d4d8d15abe23482fb4da02cd.html
	  		3.@conditionalOnAny  https://www.cnblogs.com/cxuanBlog/p/10960575.html  https://blog.csdn.net/pengjunlee/article/details/79700127

	  	5.关与 @EnableConfigurationProperties 注解 https://www.jianshu.com/p/7f54da1cb2eb

 5.自定义类型转换器 -映射 convert
 6.druid  

 
 7.接口和资源映射定位 - namespace - 自定义关系 mapperscan连接config和mapper.java关系  - 明确哪里默认配置是如何关联的  <--- 看开头 对象引用关联
 9.多数源配置和隔离-  本身就是不同的sqlsession 只是大对象 通常没有必要不这么设置浪费空间

 10.多个线程调用如何？连接池？如何使用? 如何做到线程安全的？
 		1.https://blog.csdn.net/liuxiao723846/article/details/52424802


 11.mybatis全局配置-开关 mybatis-config.xml mybatis设定全局变量:https://www.cnblogs.com/voctrals/p/8615214.html
12.框架不适用spring:启动后初始化了数据到cache/对应对象。vs 业务代码中相互调用。
13.动态代理了哪些内容？wrapper
		1.bean beandefiniton beandefinitonHolder 到底依次添加了些什么东西 *** 包含了扩展wrapper了哪些信息/
			https://blog.csdn.net/qq924862077/article/details/73558848 类似于dto 包含主要对象及其他描述
			https://www.cnblogs.com/GooPolaris/p/8177989.html

14.提供性能
	1.二级缓存  map
	2.延迟加载
	3.与db交互




=======mybatis和spring整合及全局===========
分为两类 1.mybatis自己启动  2.融合在spring中



=========tip=========

	checkConfigFileExists
	parsePendingResultMaps 
	methodCache
	静态类 - 同一个类中
	traceEnabled
	(Resource[])result.toArray(new Resource[result.size()]);转化



======核心组件的组成================

1.SqlSessionFactoryBean 
	1.外在展现DatasouceConfig <-- 可以作为二者融合的依据。从spring取值塞入mybatis的sqlSessionFactoryb:比如开关用于sql <if test = "">是否执行
	2.如何识别spring和让spring识别：FactoryBean<SqlSessionFactory>, InitializingBean, ApplicationListener<ApplicationEvent> {
	3.ResourcePatternResolver - PathMatchingResourcePatternResolver
		1.ResourceLoader
		2.PathMatcher
		3.doFindAllClassPathResources - Enumeration
	4.MetadataReaderFactory  - CachingMetadataReaderFactory
	5.Resource configLocation
		1.ResourceAdapter
	6.Configuration
		1.safeRowBoundsEnabled ...
	7.Resource[] mapperLocations
	8.DataSource
	9.TransactionFactory
		1.SpringManagedTransactionFactory/JdbcTransactionFactory/ManagedTransactionFactory
	10.SqlSessionFactoryBuilder
	11.SqlSessionFactory
	12.failFast
	13.Interceptor[] plugins  - 扩展
		1.QueryInterceptor
		2.PageInterceptor
	14.typeHandler<?>[] typeHandlers
		1.	
	15.VFS
	16.Cache
		1.查看对应的cache
		2.
	17.ObjectWrapperFactory

2.SqlSessionTemplate - faceAdsNamedParameterJdbcTemplate	
	1.PersistenceExceptionTranslator ExceptionUtil
	2.sqlSessionProxy SqlSessionInterceptor - 代理了selectOne....等实现了在sqlsession上增加了自动提交
		1.catch中对代码处理


3.sqlsessionFactory - sqlsession
   1.openSessionFromDataSource() <== 返回：transaction 不自动提交+ sqlsession 
   2.Executor vs Iterator迭代
   3.ErrorContext.instance().reset();
   4.多数据源：1.多个不同数据库  2.统一数据库的多个sqlsessionFactory - 什么时候需要配置多个呢？--sqlsession
   5.Configuration
   		1.Environment
   		2.safeRowBoundsEnabled
   		3.aggressiveLazyLoading
   		4.useGeneratedKeys - KeyGenerator
   		5.cacheEnabled   LocalCacheScope - session/statement  - 默认session  incompleteCacheRefs
   		6.AutoMappingBehavior  -- AutoMappingUnknownColumnBehavior
   		7.ReflectorFactory  
   		8.ObjectWrapperFactory
   		9.CglibProxyFactory  proxyFactory = new JavassistProxyFactory();默认使用java
   		10.MapperRegistry  -- TypeHandlerRegistry
   		11.InterceptorChain
   		12.sqlFragments
   		13.XMLStatementBuilder - MapperAnnotationBuilder
   		14.CacheRefResolver
   		15.cacheRefMap
   		16.lazyLoadTriggerMethods = new HashSet(Arrays.asList("equals", "clone", "hashCode", "toString"));
   		17.StrictMap 自定义map	-- 自动的非全限定类名映射也起作用
   		18.buildAllStatements() - parseStatementNode
   			1.this.context.getBooleanAttribute
   			2.SqlSource.getBoundSql
   	6.TransactionFactory
   		1.DataSourceUtils.isConnectionTransactional
   		2.ConnectionHolder
   			1.transactionActive
   			2.savepointsSupported
   			3.TransactionIsolationLevel
   			
 	7.executor
		1.public <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {



5.SqlSessionManager - 资源数据隔离
	1.ThreadLocal<SqlSession> localSqlSession


4.jdbcTemplate vs mapper关联

DataSourceInitializer
	1.DataSourceProperties
		1.ApplicationListener
			解耦合方式：通过applicationContext.publishEvent(new DataSourceInitializedEvent(this.dataSource));发布
			           通过DataSourceInitializer implements ApplicationListener<DataSourceInitializedEvent> onApplicationEvent来处理接听到事件
			spring如何调用这些监听到的事件呢。其实事件就是在a() ; b() 更灵活了

		2.DataSourceProperties + datasouce
		   这里需要从spring中获取datasouce，因为他们都不是一个来源。datasouce接口时java中的。 spring融合getBeanFromType....获取到


		3.@PostConstruct
			在构造方法初始化后，初始化下面的内容。顺序
		4.this.initialized = true; 标识控制   xxxenable 取代isxxx
		5.SortedResourcesFactoryBean
		6.Collections.singletonList(location)  初始化的时候，初始化列表大小
		7.ResourceDatabasePopulator
			DatabasePopulatorUtils.execute(populator, dataSource); 获取connection连接
			 ScriptUtils.executeSqlScript(connection, encodedScript, this.continueOnError, this.ignoreFailedDrops, this.commentPrefix, this.separator, this.blockCommentStartDelimiter, this.blockCommentEndDelimiter); 《---- 执行填充，调用
			 		1.readScript 其中有分割；注释--
			 		2.appendSeparatorToScriptIfNecessary
			 		3.splitSqlScript
			 		4.Statement stmt = connection.createStatement(); stmt.execute(statement);
			 		5.int rowsAffected = stmt.getUpdateCount();
			 		===问题：什么时候触发呢？

	2.hasText - containsText



https://my.oschina.net/zudajun?q=Mybatis
