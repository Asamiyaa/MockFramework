mq（） - redis（缓存设计 - 定论最后的取舍 -其他使用场景） - xml解析api文档理解 - 性能调优工具 - shell awk 等Linux 技术  - Vue - 其他技术运用
-- 问题的非等价转移 解决方案的取舍

思考：无需创建多个dto等，保存对象高效？ 对于占用相似或者对象进行‘ 池化 ’

1.mq
    1.kafaka高性能：全异步化的线程模型、高性能的异步网络传输、
                自定义的私有传输协议和序列化、反序列化
                批处理
                顺序读写：将每批消息写入对应的文件
                pageCache
                zeroCopy    直接从 PageCache 中把数据复制到 Socket 缓冲区中，这样不仅减少一次数据复
                             制，更重要的是，由于不用把数据复制到用户内存空间，DMA 控制器可以直接完成数据复
                             制，不需要 CPU 参与，速度更快。

     2.解决一致性 防丢失性的写法 - 代码落地

TODO :将menu中的异步那里改为性能  因为异步只是提高性能的手段，并把这里的缓存、批处理、压缩 、流程优化 加进去 ，redis只是缓存的一种实现

2.redis
     1.从不同角度理解redis场景  缓存、锁、分布式... RedisUse
            1.缓存
                    采用 @Cacheable 注解的方式缓存的命中率如何？或者说怎样才能
                    提高缓存的命中率？缓存是否总能返回最新的数据？如果缓存返回了过期的数据该怎么办？
                1.一致性
                    1.读写缓存  程序写入pageCache-异步磁盘同步 系统问题操作系统保证写入，断电丢失  kafka通过多个副本解决这种丢失
                    2.读缓存    从磁盘获取数据写入缓存  高并发场景下：你是选择同步还是异步来更新缓存呢？如果是同步更新，更新磁盘成功了，但是更新缓存失
                                                 败了，你是不是要反复重试来保证更新成功？如果多次重试都失败，那这次更新是算成功还
                                                 是失败呢？如果是异步更新缓存，怎么保证更新的时序？

                                                 解决方案：分布式事务 vs 定时将磁盘数据同步(不及时) - 全量 vs 增量   vs 过期
                                                             转账(不适用缓存或者分布式强一致性)      后两者比如邮件、微信头像

                                                             一定要合适的场景使用，不要死扣强一致性  人生也是这样要审时度势
                2.在内存有限的情况下，要优先缓存哪些数据，让缓存的命中率最高  - 缓存穿透 - 缓存置换  - 策略（命中率最高的置换策略，一定是根据你的业务逻辑，定制化的策略 -  LRU 算法 - 位置权重）

3.批处理
4.数据压缩  压缩耗时 + 传输压缩数据耗时 + 解压耗时。压缩它的本质是资源的置换，是一个时间换空间，或者说是 CPU 资源换存储资源的游戏。提高写入和数据传输
5.业务流程优化，数据结构调整  比如kafka就将从pageCache - 用户内存 - socket内存转为 pageCache - socket
6.分段、分片、分库表　分组　设权限



TODO:1.设计关于jms中使用mq\需要注意的东西 各种特性 幂等、事务、...的处理 明确问题和解决方案 取舍